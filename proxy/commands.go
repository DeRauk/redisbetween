package proxy

var SupportedCommands = map[string]bool{
	"APPEND":               true,
	"AUTH":                 true,
	"BGREWRITEAOF":         true,
	"BGSAVE":               true,
	"BITCOUNT":             true,
	"BITFIELD":             true,
	"BITOP":                true,
	"BITPOS":               true,
	"COMMAND":              true,
	"DECR":                 true,
	"DECRBY":               true,
	"DEL":                  true, // TODO special considerations for clusters?
	"DUMP":                 true,
	"ECHO":                 true,
	"EVAL":                 true,
	"EVALSHA":              true,
	"EXISTS":               true, // TODO special considerations for clusters?
	"EXPIRE":               true,
	"EXPIREAT":             true,
	"FLUSHALL":             true,
	"FLUSHDB":              true,
	"GEOADD":               true,
	"GEODIST":              true,
	"GEOHASH":              true,
	"GEOPOS":               true,
	"GEORADIUS":            true,
	"GEORADIUSBYMEMBER":    true,
	"GEORADIUSBYMEMBER_RO": true,
	"GEORADIUS_RO":         true,
	"GET":                  true,
	"GETBIT":               true,
	"GETRANGE":             true,
	"GETSET":               true,
	"HDEL":                 true,
	"HEXISTS":              true,
	"HGET":                 true,
	"HGETALL":              true,
	"HINCRBY":              true,
	"HINCRBYFLOAT":         true,
	"HKEYS":                true,
	"HLEN":                 true,
	"HMGET":                true,
	"HMSET":                true,
	"HOST":                 true,
	"HSCAN":                true,
	"HSET":                 true,
	"HSETNX":               true,
	"HSTRLEN":              true,
	"HVALS":                true,
	"INCR":                 true,
	"INCRBY":               true,
	"INCRBYFLOAT":          true,
	"KEYS":                 true, // TODO special considerations for clusters?
	"LASTSAVE":             true,
	"LINDEX":               true,
	"LINSERT":              true,
	"LLEN":                 true,
	"LOLWUT":               true, // :D
	"LPOP":                 true,
	"LPUSH":                true,
	"LPUSHX":               true,
	"LRANGE":               true,
	"LREM":                 true,
	"LSET":                 true,
	"LTRIM":                true,
	"MGET":                 true, // TODO clusters?
	"MOVE":                 true,
	"MSET":                 true,
	"MSETNX":               true,
	"OBJECT":               true,
	"PERSIST":              true,
	"PEXPIRE":              true,
	"PEXPIREAT":            true,
	"PFADD":                true,
	"PFCOUNT":              true,
	"PFMERGE":              true,
	"PING":                 true,
	"POST":                 true,
	"PSETEX":               true,
	"PTTL":                 true,
	"RANDOMKEY":            true,
	"RENAME":               true,
	"RENAMENX":             true,
	"RESTORE":              true,
	"RPOP":                 true,
	"RPOPLPUSH":            true,
	"RPUSH":                true,
	"RPUSHX":               true,
	"SADD":                 true,
	"SAVE":                 true,
	"SCAN":                 true,
	"SCARD":                true,
	"SDIFF":                true,
	"SELECT":               true, // cluster only supports one db, so I don't think this can work?
	"SET":                  true,
	"SETBIT":               true,
	"SETEX":                true,
	"SETNX":                true,
	"SETRANGE":             true,
	"SINTER":               true,
	"SISMEMBER":            true,
	"SMEMBERS":             true,
	"SMOVE":                true,
	"SORT":                 true,
	"SPOP":                 true,
	"SRANDMEMBER":          true,
	"SREM":                 true,
	"SSCAN":                true,
	"STRLEN":               true,
	"SUBSTR":               true,
	"SUNION":               true,
	"SWAPDB":               true,
	"TOUCH":                true, // clusters?
	"TTL":                  true,
	"TYPE":                 true,
	"UNLINK":               true, // clusters?
	"XACK":                 true,
	"XADD":                 true,
	"XCLAIM":               true,
	"XDEL":                 true,
	"XGROUP":               true,
	"XINFO":                true,
	"XLEN":                 true,
	"XPENDING":             true,
	"XRANGE":               true,
	"XREVRANGE":            true,
	"XSETID":               true,
	"XTRIM":                true,
	"ZADD":                 true,
	"ZCARD":                true,
	"ZCOUNT":               true,
	"ZINCRBY":              true,
	"ZLEXCOUNT":            true,
	"ZPOPMAX":              true,
	"ZPOPMIN":              true,
	"ZRANGE":               true,
	"ZRANGEBYLEX":          true,
	"ZRANGEBYSCORE":        true,
	"ZRANK":                true,
	"ZREM":                 true,
	"ZREMRANGEBYLEX":       true,
	"ZREMRANGEBYRANK":      true,
	"ZREMRANGEBYSCORE":     true,
	"ZREVRANGE":            true,
	"ZREVRANGEBYLEX":       true,
	"ZREVRANGEBYSCORE":     true,
	"ZREVRANK":             true,
	"ZSCAN":                true,
	"ZSCORE":               true,

	// TODO are these commands ok? redis-cluster-proxy doesn't allow cross-slot commands and i'm not sure why. maybe
	// because it's not possible to respect a MOVED redirect with these commands?
	"SDIFFSTORE":  true,
	"SINTERSTORE": true,
	"SUNIONSTORE": true,
	"ZINTERSTORE": true,
	"ZUNIONSTORE": true,
}

var UnsupportedCommands = map[string]bool{
	"ACL":          false,
	"ASKING":       false,
	"CLIENT":       false,
	"CLUSTER":      false, // this gets intercepted
	"CONFIG":       false,
	"DBSIZE":       false, // doesnt make sense for clusters?
	"DEBUG":        false,
	"HELLO":        false, // RESP3 protocol handshake
	"INFO":         false,
	"LATENCY":      false,
	"MEMORY":       false,
	"MIGRATE":      false,
	"MODULE":       false,
	"MONITOR":      false,
	"PFDEBUG":      false,
	"PFSELFTEST":   false,
	"PSUBSCRIBE":   false,
	"PSYNC":        false,
	"PUBLISH":      false,
	"PUBSUB":       false,
	"PUNSUBSCRIBE": false,
	"READONLY":     false,
	"READWRITE":    false,
	"REPLCONF":     false,
	"REPLICAOF":    false,
	"ROLE":         false,
	"SCRIPT":       false,
	"SHUTDOWN":     false,
	"SLAVEOF":      false,
	"SLOWLOG":      false,
	"SUBSCRIBE":    false,
	"SYNC":         false,
	"TIME":         false,
	"UNSUBSCRIBE":  false,
	"WAIT":         false,

	// redis transactions are stateful on the server side, and are associated with the connection. for a connection pooling
	// proxy that shares a single connection among multiple clients, it doesn't make sense to support transactions, as
	// each one monopolizes a connection from the pool as long as it is open, just like blocking commands.
	"DISCARD": true,
	"EXEC":    true,
	"MULTI":   true,
	"UNWATCH": true,
	"WATCH":   true,

	// blocking commands cause clients to hold a connection open and wait for data to appear. these monopolize a connection
	// from the pool, so don't make sense to allow for a connection pooling proxy. if these are required in the future, we
	// could allow ad-hoc connections to be allocated in addition to the pool to support these?
	"BLPOP":      true,
	"BRPOP":      true,
	"BRPOPLPUSH": true,
	"BZPOPMAX":   true,
	"BZPOPMIN":   true,
	"XREAD":      true, // streams
	"XREADGROUP": true, // streams
}

func KnownCommand(c string) bool {
	return SupportedCommand(c) || UnsupportedCommand(c)
}
func SupportedCommand(c string) bool {
	_, ok := SupportedCommands[c]
	return ok
}
func UnsupportedCommand(c string) bool {
	_, ok := UnsupportedCommands[c]
	return ok
}
